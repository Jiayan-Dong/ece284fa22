$date
	Wed Oct 26 02:13:28 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mac_tb $end
$var wire 16 ! out [15:0] $end
$var reg 16 " c [15:0] $end
$var reg 1 # clk $end
$var reg 16 $ expected_out [15:0] $end
$var integer 32 % i [31:0] $end
$var integer 32 & w_dec [31:0] $end
$var integer 32 ' w_file [31:0] $end
$var integer 32 ( w_scan_file [31:0] $end
$var integer 32 ) x_dec [31:0] $end
$var integer 32 * x_file [31:0] $end
$var integer 32 + x_scan_file [31:0] $end
$scope function mac_predicted $end
$var reg 4 , a0 [3:0] $end
$var reg 4 - a1 [3:0] $end
$var reg 4 . a2 [3:0] $end
$var reg 4 / a3 [3:0] $end
$var reg 4 0 b0 [3:0] $end
$var reg 4 1 b1 [3:0] $end
$var reg 4 2 b2 [3:0] $end
$var reg 4 3 b3 [3:0] $end
$var reg 16 4 c [15:0] $end
$upscope $end
$scope function w_bin $end
$var integer 32 5 weight [31:0] $end
$upscope $end
$scope function x_bin $end
$var integer 32 6 activation [31:0] $end
$upscope $end
$scope module mac_wrapper_instance $end
$var wire 4 7 a0 [3:0] $end
$var wire 4 8 a1 [3:0] $end
$var wire 4 9 a2 [3:0] $end
$var wire 4 : a3 [3:0] $end
$var wire 4 ; b0 [3:0] $end
$var wire 4 < b1 [3:0] $end
$var wire 4 = b2 [3:0] $end
$var wire 4 > b3 [3:0] $end
$var wire 16 ? c [15:0] $end
$var wire 1 # clk $end
$var wire 16 @ out [15:0] $end
$var reg 16 A c_q [15:0] $end
$scope module mac_instance $end
$var wire 4 B a0 [3:0] $end
$var wire 4 C a1 [3:0] $end
$var wire 4 D a2 [3:0] $end
$var wire 4 E a3 [3:0] $end
$var wire 4 F b0 [3:0] $end
$var wire 4 G b1 [3:0] $end
$var wire 4 H b2 [3:0] $end
$var wire 4 I b3 [3:0] $end
$var wire 16 J c [15:0] $end
$var wire 16 K out [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
b10000000000000000000000000000100 *
bx )
bx (
b10000000000000000000000000000011 '
bx &
bx %
b0 $
0#
bx "
bx !
$end
#2
1#
#3
b0 %
0#
#4
1#
#5
b100 %
b1111111111010000 $
b110 ,
b111 -
b1 .
b11 /
b1 0
b1001 1
b111 2
b1100 3
b0 4
b0 "
b0 ?
b1100 >
b11 :
b111 =
b1 9
b1001 <
b111 8
b1 ;
b0 5
b110 7
b1 6
b1 +
b11 )
b1 (
b11111111111111111111111111111100 &
0#
#6
b1111111111010000 !
b1111111111010000 @
b1111111111010000 K
b0 A
b0 J
b11 E
b1 D
b111 C
b110 B
b1100 I
b111 H
b1001 G
b1 F
1#
#7
b1000 %
b1111111110011110 $
b10 ,
b10 -
b1111 .
b100 /
b1101 0
b1110 1
b1100 2
b101 3
b1111111111010000 4
b1111111111010000 "
b1111111111010000 ?
b101 >
b100 :
b1100 =
b1111 9
b1110 <
b10 8
b1101 ;
b1 5
b10 7
b0 6
b100 )
b101 &
0#
#8
b1111111111010000 A
b1111111111010000 J
b100 E
b1111 D
b10 C
b10 B
b101 I
b1100 H
b1110 G
b1111111110011110 !
b1111111110011110 @
b1111111110011110 K
b1101 F
1#
#9
b1100 %
b1111111110000110 $
b110 ,
b100 -
b0 .
b10 /
b1010 0
b100 1
b10 2
b1110 3
b1111111110011110 4
b1111111110011110 "
b1111111110011110 ?
b1110 >
b10 :
b10 =
b0 9
b100 <
b100 8
b1010 ;
b0 5
b110 7
b0 6
b10 )
b11111111111111111111111111111110 &
0#
#10
b1111111110011110 A
b1111111110011110 J
b10 E
b0 D
b100 C
b110 B
b1110 I
b10 H
b100 G
b1111111110000110 !
b1111111110000110 @
b1111111110000110 K
b1010 F
1#
#11
b10000 %
b1111111101011001 $
b1 ,
b1010 -
b10 .
b1011 /
b0 0
b1100 1
b11 2
b1111 3
b1111111110000110 4
b1111111110000110 "
b1111111110000110 ?
b1111 >
b1011 :
b11 =
b10 9
b1100 <
b1 5
b1010 8
b0 ;
b1 7
b1 6
b1011 )
b11111111111111111111111111111111 &
0#
#12
b1111111110000110 A
b1111111110000110 J
b1011 E
b10 D
b1010 C
b1 B
b1111 I
b11 H
b1100 G
b1111111101011001 !
b1111111101011001 @
b1111111101011001 K
b0 F
1#
#13
b10100 %
b1111111101111111 $
b10 ,
b110 -
b100 .
b1010 /
b1100 0
b101 1
b1010 2
b100 3
b1111111101011001 4
b1111111101011001 "
b1111111101011001 ?
b100 >
b1010 :
b1010 =
b100 9
b101 <
b110 8
b1100 ;
b0 5
b10 7
b0 6
b1010 )
b100 &
0#
#14
b1111111101011001 A
b1111111101011001 J
b1010 E
b100 D
b110 C
b10 B
b100 I
b1010 H
b101 G
b1111111101111111 !
b1111111101111111 @
b1111111101111111 K
b1100 F
1#
#15
0#
#25
